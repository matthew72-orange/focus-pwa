<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Focus Timer PWA</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111111">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icon-180.png">
<style>
  :root{--bg:#0b0b0c;--fg:#f7f7f8;--muted:#9aa0a6;--accent:#4f8cff;}
  html,body{height:100%;}
  body{margin:0; font-family:-apple-system, system-ui, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Yu Gothic UI", "Noto Sans JP", sans-serif; background:var(--bg); color:var(--fg); display:flex; align-items:center; justify-content:center;}
  .card{width:min(720px, 92vw); padding:20px 20px 28px; border-radius:20px; background:#151517; box-shadow:0 10px 30px rgba(0,0,0,.35);}
  h1{margin:4px 0 12px; font-size:22px; font-weight:700;}
  label{display:block; margin:12px 0 4px; color:var(--muted);}
  input, select{width:100%; padding:12px 14px; border-radius:12px; border:1px solid #2a2a2e; background:#0f0f11; color:var(--fg); font-size:18px; outline:none;}
  button{appearance:none; border:0; border-radius:14px; padding:12px 16px; font-size:18px; font-weight:700; color:white; background:var(--accent); cursor:pointer;}
  .row{display:flex; gap:12px; align-items:center;}
  .row>*{flex:1}
  .muted{color:var(--muted); font-size:14px;}
  .center{display:flex; align-items:center; justify-content:center; text-align:center;}
  .timer{font-variant-numeric:tabular-nums; font-size:64px; letter-spacing:1px; margin:6px 0 18px;}
  .affirm{font-size:22px; margin:6px 0 10px;}
  .pill{display:inline-block; padding:4px 10px; border-radius:999px; background:#232327; color:#c9ccd1; font-size:13px;}
  .stack{display:flex; flex-direction:column; gap:12px;}
  .hidden{display:none !important;}
</style>
</head>
<body>
  <div class="card">
    <h1>Focus Timer</h1>

    <div id="setup" class="stack">
      <div>
        <label>やること</label>
        <input id="task" placeholder="英語/数学/読書 など" autocomplete="on">
      </div>
      <div class="row">
        <div>
          <label>目標時間（分）</label>
          <select id="mins">
            <option>1</option><option>25</option><option selected>50</option><option>90</option><option>120</option>
          </select>
        </div>
        <div>
          <label>通知メール（任意・サーバ経由）</label>
          <input id="email" placeholder="family@example.com">
        </div>
      </div>
      <div class="muted">※メール送信はサーバのエンドポイント設定が必要です（<code>config.endpoint</code> を編集）。</div>
      <div class="row">
        <label style="width:100%">
          家族コード（任意・共有用）
          <input id="familyCode" type="text" placeholder="例: SUMMER-2025" inputmode="latin" autocomplete="off">
        </label>
      </div>
      <div class="row" style="align-items:center">
        <label>
          <input id="isFamily" type="checkbox">
          この端末は家族の通知受信用
        </label>
      </div>
      <div class="row">
        <button id="startBtn">スタート</button>
        <button id="installBtn" class="hidden">ホーム追加</button>
      </div>
      <!-- ★追加: CSV / クリア -->
      <div class="row">
        <button id="csvBtn" style="background:#2a6">履歴CSVをダウンロード</button>
        <button id="clearBtn" style="background:#444">履歴クリア</button>
      </div>
      <div class="row">
        <button id="notifyBtn" style="background:#6c5ce7">通知を有効化</button>
        <button id="testPushBtn" style="background:#0984e3">テスト通知</button>
      </div>
<div class="muted">※ iPhoneはホーム画面に追加したPWAでのみPushが動作します。</div>

    </div>

    <div id="run" class="hidden center" style="flex-direction:column;">
      <div class="pill" id="taskLabel">Task</div>
      <div class="affirm">集中中。わたしはやれる。💪</div>
      <div class="timer" id="remain">00:00</div>
      <div class="row" style="width:100%;"><button id="stopBtn" style="background:#e64a4a">中断（Fail）</button></div>
      <div class="muted" style="margin-top:10px">⚠️ この画面から離れると即 Fail になります。</div>
    </div>

  <div id="recent" class="card" style="margin-top:16px">
  <h2 style="font-size:18px;margin:4px 0 10px">直近10件</h2>
  <table id="recentTable" style="width:100%;border-collapse:collapse;font-size:14px">
    <thead><tr>
      <th style="text-align:left;padding:6px;border-bottom:1px solid #333">日時</th>
      <th style="text-align:left;padding:6px;border-bottom:1px solid #333">タスク</th>
      <th style="text-align:right;padding:6px;border-bottom:1px solid #333">分</th>
      <th style="text-align:left;padding:6px;border-bottom:1px solid #333">結果</th>
    </tr></thead>
    <tbody></tbody>
  </table>
  </div>
  </div>

<script>
// ------- 基本設定（必要に応じて編集） -------
const config = {
  endpoint: "https://example.com/focus_log", // ← あなたのGAS/Flask URLに変更
  enablePost: false, // サーバ未設定なら false のままでOK（POSTしない）
  // ★ 追加：Push用
  pushServer: "https://focus-push-server.onrender.com", // ← 後述のNodeサーバのURL
  vapidPublicKey: "BN2H6Gwrup9ZGFSGS7QwBDmh3OeSveTCpQhyX-pdzR5au2sXNC5eOMEdiY2Teoi86w6XjoMLoiUCTiOcl4W6oPY" // ← web-pushで生成した公開鍵
};

let audioCtx = null, audioUnlocked = false;
function initAudioUnlock(){
  if (audioUnlocked) return;
  const Ctx = window.AudioContext || window.webkitAudioContext;
  if (!Ctx) return;
  audioCtx = new Ctx();
  // ごく短い可聴トーンで“音を解錠”
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  gain.gain.value = 0.001; // ほぼ無音
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  setTimeout(()=>{ osc.stop(); audioUnlocked = true; }, 60);
}

async function ensureAudioReady(){
  if (!audioCtx) initAudioUnlock();
  try { await audioCtx.resume(); } catch(e){}
}
window.addEventListener('pointerdown', ensureAudioReady, {passive:true});
document.addEventListener('visibilitychange', () => {
  if (!document.hidden) ensureAudioReady();
});

  
// 成功/失敗用の簡易チャイム（fallback）
async function beep(freq=880, ms=220){
  await ensureAudioReady();
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  gain.gain.value = 0.22;             // ← 少し大きめ（必要なら0.25まで）
  osc.type = 'sine';
  osc.frequency.value = freq;
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  setTimeout(()=>{
    try{ gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.12); }catch(e){}
  }, Math.max(60, ms-120));
  setTimeout(()=>{ try{ osc.stop(); }catch(e){} }, ms+80);
}

function urlBase64ToUint8Array(base64String){
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i=0; i<rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
  return outputArray;
}

async function subscribePush(){
  if (!('serviceWorker' in navigator)) return alert('Service Worker未対応');
  if (!('PushManager' in window)) return alert('Push未対応ブラウザです');

  const perm = await Notification.requestPermission();
  if (perm !== 'granted') { alert('通知が許可されませんでした'); return; }

  const reg = await navigator.serviceWorker.ready;
  const sub = await reg.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: urlBase64ToUint8Array(config.vapidPublicKey)
  });

  // deviceId を保持
  let devId = localStorage.getItem('deviceId');
  if (!devId) {
    const a = new Uint8Array(16); crypto.getRandomValues(a);
    devId = [...a].map(x=>x.toString(16).padStart(2,'0')).join('');
    localStorage.setItem('deviceId', devId);
  }

  const familyCode = (localStorage.getItem('familyCode') || '').trim() || null;
  const role = (localStorage.getItem('isFamily') === '1') ? 'family' : 'self';

  await fetch(config.pushServer + '/api/save-subscription', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ deviceId: devId, role, familyCode, subscription: sub })
  });

  alert('通知を有効化しました');
}

async function testPush(){
  let devId = localStorage.getItem('deviceId');
  if (!devId) return alert('先に「通知を有効化」してください');
  await fetch(config.pushServer + '/api/test-push', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ deviceId: devId, title:'テスト通知', body:'Focus Timerからのテストです' })
  });
  alert('テスト通知を送信しました（数秒お待ちください）');
}

  
// ------- PWA: SW登録 -------
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').catch(()=>{});
  });
}

// ------- 画面要素 -------
const $ = s => document.querySelector(s);
const setup = $('#setup'), run = $('#run');
const startBtn = $('#startBtn'), stopBtn = $('#stopBtn'); // ← これ！
const taskInput = $('#task'), minsSel = $('#mins'), emailInput = $('#email');
const remain = $('#remain'), taskLabel = $('#taskLabel');
let startAt = null, targetSec = 0, tHandle = null, currentTask = "", userEmail = "";
// ---- 履歴（ローカル保存） ----
let sessions = JSON.parse(localStorage.getItem('sessions') || '[]'); // 配列
function saveSessions() {
  if (sessions.length > 1000) sessions = sessions.slice(-1000); // 一応の上限
  localStorage.setItem('sessions', JSON.stringify(sessions));
}

const familyCodeInput = document.getElementById('familyCode');
const isFamilyInput = document.getElementById('isFamily');

// ロード時に復元
familyCodeInput.value = localStorage.getItem('familyCode') || '';
isFamilyInput.checked = localStorage.getItem('isFamily') === '1';

// 入力変更を保存
familyCodeInput.addEventListener('change', ()=> {
  localStorage.setItem('familyCode', familyCodeInput.value.trim());
});
isFamilyInput.addEventListener('change', ()=> {
  localStorage.setItem('isFamily', isFamilyInput.checked ? '1' : '0');
});
  

// ------- ホーム追加（主にAndroid/一部ブラウザ） -------
let deferredPrompt = null;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault(); deferredPrompt = e;
  const ib = $('#installBtn');
  ib.classList.remove('hidden');
  ib.onclick = async () => { deferredPrompt.prompt(); deferredPrompt = null; ib.classList.add('hidden'); };
});

// ------- 画面離脱＝Fail -------
document.addEventListener('visibilitychange', () => {
  if (document.hidden) endSession(false, 'left-app');
});

// ------- スタート/ストップ -------
startBtn.addEventListener('click', async () => {
  currentTask = taskInput.value.trim() || 'Untitled';
  userEmail = emailInput.value.trim();
  const mins = parseInt(minsSel.value, 10);
  startSession(currentTask, mins);
});

document.getElementById('notifyBtn').addEventListener('click', subscribePush);
document.getElementById('testPushBtn').addEventListener('click', testPush);

document.getElementById('csvBtn').addEventListener('click', downloadCSV);
document.getElementById('clearBtn').addEventListener('click', clearHistory);

// 起動時に1回描画
renderRecent();
  
stopBtn.addEventListener('click', () => endSession(false, 'manual'));

function startSession(task, mins){
  initAudioUnlock(); // ← 追加：ユーザー操作直後に音を解錠
  prepareTTS();                 // ★追加：ここでTTSを起こす
  startAt = new Date();
  targetSec = mins * 60;
  setup.classList.add('hidden');
  run.classList.remove('hidden');
  taskLabel.textContent = task;
  updateTimer(); tHandle = setInterval(updateTimer, 250);
  // 画面を落とさない（二重保険）
  startKeepAwake();


  // 初回ユーザー操作後の音声権限を確保
  try { window.speechSynthesis.cancel(); } catch(e){}
}

function updateTimer(){
  const elapsed = Math.floor((Date.now()-startAt.getTime())/1000);
  const left = Math.max(0, targetSec - elapsed);
  remain.textContent = fmt(left);
  if (left === 0) endSession(true, 'target');
}

async function endSession(success, reason){
  if (!startAt) return;
  clearInterval(tHandle); tHandle = null;
  const endedAt = new Date();
  const minutes = Math.floor((endedAt - startAt)/60000);
  const payload = {
    task: currentTask, email: userEmail || null,
    started_at: startAt.toISOString(), ended_at: endedAt.toISOString(),
    success, reason, minutes
  };

  // endSession 内、payload 作成後あたり
  fetch(config.pushServer + '/api/test-push', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({
      deviceId: localStorage.getItem('deviceId'),
      title: success ? '🎉 目標達成！' : '⏸️ 中断されました',
      body: `${currentTask} / ${minutes}分`
    })
  }).catch(()=>{});
  
  // ★ 履歴に追加 → 保存 → 一覧更新
  sessions.push(payload);
  saveSessions();
  renderRecent();
  
  // フィードバック（音/読み上げ/バイブ）
  try { navigator.vibrate && navigator.vibrate(success ? [40,40,40] : [160]); } catch(e){}
  if (success) {
    beep(1046, 220); setTimeout(()=>beep(1318, 240), 200); // 上昇2音
    setTimeout(()=>speak(`お疲れ様。目標時間、${minutes} 分。ひと息いれましょうか？`), 420);
  } else {
    beep(392, 260); setTimeout(()=>beep(330, 260), 260);   // 下降2音
    setTimeout(()=>speak(`着座してから ${minutes} 分しか経っていません。もう少し頑張れます。`), 520);
  }

  // …既存の表示/音声/バイブ処理の後あたりに追加…
  try {
    const devId = localStorage.getItem('deviceId');
    const familyCode = (localStorage.getItem('familyCode') || '').trim() || null;
    const title = success ? '🎉 目標達成！' : '⏸️ 中断されました';
    const body  = `${currentTask} / ${minutes}分`;
    const url   = location.origin;
    fetch(config.pushServer + '/api/focus-result', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ deviceId: devId, familyCode, title, body, url })
    }).catch(()=>{});
  } catch(e) {}

  
  // サーバPOST（任意）
  if (config.enablePost) {
    fetch(config.endpoint, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    }).catch(()=>{});
  }

  // ★ 成功／失敗メッセージを表示（既存UIは一時的に非表示）
  const olds = Array.from(run.children);
  olds.forEach(el => el.classList.add('hidden'));

  const msg = document.createElement("div");
  msg.style.fontSize = "22px";
  msg.style.margin = "20px 0";
  msg.textContent = success
    ? `🎉 お疲れ様！${minutes}分達成しました！`
    : `💤 ${minutes}分で中断されました`;
  run.appendChild(msg);

  // 4秒後に初期画面へ戻す（UIも元に戻す）
  setTimeout(() => {
    run.removeChild(msg);
    olds.forEach(el => el.classList.remove('hidden'));
    run.classList.add('hidden');
    setup.classList.remove('hidden');
    startAt = null;
    // ← ここはまとめて停止（WakeLock & 動画）
    stopKeepAwake();
  }, 4000);
} // ←←← ★ これが endSession() を閉じるカッコ
// （この下に function speak(...) / function fmt(...) が続く）
  
let jaVoice = null;
function pickJaVoice(){
  const voices = window.speechSynthesis?.getVoices?.() || [];
  // 日本語優先（Kyoko/Otoya/“ja-JP”など）
  jaVoice = voices.find(v => (v.lang||"").toLowerCase().startsWith("ja"))
        || voices.find(v => /kyoko|otoya/i.test(v.name||""))
        || null;
}
if ('speechSynthesis' in window) {
  window.speechSynthesis.onvoiceschanged = pickJaVoice;
  // 端末によっては即取得できることもある
  setTimeout(pickJaVoice, 300);
}

// 追加：声一覧が揃うまで待つ
function waitForVoices(timeout=1500){
  return new Promise(resolve=>{
    if (speechSynthesis.getVoices().length) return resolve();
    const timer = setTimeout(()=>{ speechSynthesis.onvoiceschanged=null; resolve(); }, timeout);
    speechSynthesis.onvoiceschanged = ()=>{ clearTimeout(timer); speechSynthesis.onvoiceschanged=null; resolve(); };
  });
}

// 追加：一部iOSで勝手にpauseされる問題の対策
function speakWithResume(utter){
  try{
    speechSynthesis.cancel();
    speechSynthesis.speak(utter);
    let tries = 12; // ≒ 2.4秒だけ監視
    const id = setInterval(()=>{
      if (!speechSynthesis.speaking && !speechSynthesis.pending) { clearInterval(id); return; }
      if (speechSynthesis.paused) { try{ speechSynthesis.resume(); }catch(e){} }
      if (--tries<=0) clearInterval(id);
    }, 200);
  }catch(e){}
}

// 追加：TTSを事前に目覚めさせる（超短いダミー発話）
async function prepareTTS(){
  if (!('speechSynthesis' in window)) return;
  await waitForVoices(4000);    // ← タイムアウトを 4000ms に
  pickJaVoice();
  const u = new SpeechSynthesisUtterance(' '); // 空白1文字（無音に近い）
  if (jaVoice) u.voice = jaVoice;
  u.lang = 'ja-JP'; u.rate = 1.0; u.pitch = 1.0; u.volume = 0.01; // ほぼ無音
  speakWithResume(u);
}
  
async function speak(text){
  if (!('speechSynthesis' in window)) return;
  await ensureAudioReady();           // ← WebAudio側も確実に再開
  await waitForVoices();              // ← 声が揃うまで待つ
  pickJaVoice();
  const u = new SpeechSynthesisUtterance(text);
  if (jaVoice) u.voice = jaVoice;
  u.lang = 'ja-JP'; u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
  speakWithResume(u);                 // ← ワークアラウンド付きで発話
}

// ===== KEEP-AWAKE（WakeLock + 無音動画ループ + リトライ） =====
let wakeLock = null;
let keepAwakeVideo = null;
let keepAwakeRetryTimer = null;
let keepAwakeRetries = 0;

async function requestWakeLock(){
  if (!('wakeLock' in navigator)) return false;
  try {
    wakeLock = await navigator.wakeLock.request('screen');
    wakeLock.addEventListener('release', () => {
      // 自動的に解放される場合がある（バッテリー/OS判断）
      // コンソールでわかるように
      console.log('[WakeLock] released');
    });
    console.log('[WakeLock] acquired');
    return true;
  } catch (e) {
    console.log('[WakeLock] failed:', e && e.message);
    return false;
  }
}

function ensureKeepAwakeVideo(){
  if (keepAwakeVideo && !keepAwakeVideo.isConnected) {
    // DOMから消えてたら捨てる
    keepAwakeVideo = null;
  }
  if (!keepAwakeVideo) {
    const v = document.createElement('video');
    v.setAttribute('playsinline','');
    v.muted = true;
    v.loop = true;
    // 1px無音mp4（超短）—データURL
    v.src = "data:video/mp4;base64,AAAAIGZ0eXBpc28yAAAAAGlzbzJpc28yYXZjMQAAAAhmcmVlAAAAH21kYXQAAAAAAAABAAAAGG1vb3YAAABsbXZoZAAAAAB8AAABcAAAAgABAAAB9AAACABAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==";
    v.style.position = 'fixed';
    v.style.width = '1px';
    v.style.height = '1px';
    v.style.opacity = '0';
    v.style.pointerEvents = 'none';
    document.body.appendChild(v);
    keepAwakeVideo = v;
  }
  return keepAwakeVideo;
}

async function playKeepAwakeVideo(){
  const v = ensureKeepAwakeVideo();
  try {
    // 既に再生中ならスキップ
    if (!v.paused && !v.ended) return true;
    await v.play();
    console.log('[KeepAwakeVideo] playing');
    keepAwakeRetries = 0;
    return true;
  } catch (e) {
    console.log('[KeepAwakeVideo] play failed:', e && e.message);
    return false;
  }
}

// バックオフ付きで video.play() を再試行
function scheduleKeepAwakeRetry(){
  clearTimeout(keepAwakeRetryTimer);
  keepAwakeRetries = Math.min(keepAwakeRetries + 1, 6);
  const delay = 300 * keepAwakeRetries; // 0.3s, 0.6s, … 最大 ~1.8s
  keepAwakeRetryTimer = setTimeout(async () => {
    const ok = await playKeepAwakeVideo();
    if (!ok) scheduleKeepAwakeRetry();
  }, delay);
}

async function startKeepAwake(){
  // 1) WakeLock（対応ブラウザ）
  const wl = await requestWakeLock();
  // 2) 無音動画ループ（iOS含む）
  const ok = await playKeepAwakeVideo();
  if (!ok) scheduleKeepAwakeRetry();
  // 3) ユーザー操作/復帰で再開
  window.addEventListener('pointerdown', resumeKeepAwake, {passive:true});
  document.addEventListener('visibilitychange', onVisibility, {passive:true});
  window.addEventListener('pagehide', onPageHide, {passive:true});
  console.log('[KeepAwake] started', {wakeLock: wl, video: ok});
}

async function resumeKeepAwake(){
  // WakeLockはフォアグラウンド復帰時に外れてることがある
  if (!wakeLock) await requestWakeLock();
  const ok = await playKeepAwakeVideo();
  if (!ok) scheduleKeepAwakeRetry();
}

function onVisibility(){
  if (!document.hidden) {
    // 復帰時は再開
    resumeKeepAwake();
  }
}

function onPageHide(){
  // iOSでBackForwardCacheに入る際の対策
  stopKeepAwake();
}

function stopKeepAwake(){
  clearTimeout(keepAwakeRetryTimer);
  keepAwakeRetryTimer = null;
  keepAwakeRetries = 0;
  if (wakeLock) { try{ wakeLock.release(); }catch(e){} wakeLock = null; }
  if (keepAwakeVideo) {
    try{ keepAwakeVideo.pause(); }catch(e){}
    keepAwakeVideo.remove();
    keepAwakeVideo = null;
  }
  window.removeEventListener('pointerdown', resumeKeepAwake, {passive:true});
  document.removeEventListener('visibilitychange', onVisibility, {passive:true});
  window.removeEventListener('pagehide', onPageHide, {passive:true});
  console.log('[KeepAwake] stopped');
}
// ===== /KEEP-AWAKE =====

function toCSV(rows){
  const header = ["date","task","started_at","ended_at","minutes","result"];
  const esc = s => `"${String(s).replace(/"/g,'""')}"`; // RFC4180風エスケープ
  const body = rows.map(r => [
    esc(new Date(r.ended_at || r.started_at).toLocaleString('ja-JP', {hour12:false})),
    esc(r.task || ""),
    esc(r.started_at || ""),
    esc(r.ended_at || ""),
    esc(r.minutes ?? ""),
    esc(r.success ? "success" : "fail"),
  ].join(","));
  return [header.join(","), ...body].join("\r\n");
}

function downloadCSV(){
  if (!sessions.length){ alert("まだ記録がありません。"); return; }
  const csv = toCSV(sessions);
  const blob = new Blob(["\uFEFF"+csv], {type: "text/csv;charset=utf-8"}); // UTF-8+BOMでExcel/iOS対策
  const ymd = new Date().toISOString().slice(0,10);
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `focus_log_${ymd}.csv`;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 1000);
}

function clearHistory(){
  if (!confirm("履歴を削除します。よろしいですか？")) return;
  sessions = [];
  saveSessions();
  renderRecent();
  alert("履歴を削除しました。");
}

function renderRecent(){
  const tb = document.querySelector('#recentTable tbody');
  if (!tb) return;
  tb.innerHTML = '';
  const last10 = [...sessions].slice(-10).reverse();
  for (const r of last10){
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td style="padding:6px;border-bottom:1px solid #222">
        ${new Date(r.ended_at || r.started_at).toLocaleString('ja-JP', {hour12:false})}
      </td>
      <td style="padding:6px;border-bottom:1px solid #222">${(r.task||'')}</td>
      <td style="padding:6px;border-bottom:1px solid #222;text-align:right">${r.minutes ?? ''}</td>
      <td style="padding:6px;border-bottom:1px solid #222">${r.success ? '✅成功' : '❌失敗'}</td>`;
    tb.appendChild(tr);
  }
}

function fmt(sec){
  const m = Math.floor(sec/60), s = sec%60;
  return String(m).padStart(2,'0') + ":" + String(s).padStart(2,'0');
}
</script>
</body>
</html>
